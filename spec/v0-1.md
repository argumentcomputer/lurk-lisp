# Lurk Language Specification

Lurk is a statically scoped dialect of Lisp, influenced by Scheme and Common Lisp.

## Acks

Some parts of this specification repeat R5RS.

## Notes

An error is raised when a program does not satisfy a _"must"_ or _"should"_ clause. We use _"must"_ clauses for syntactic requirements and _"should"_ for semantic requirements.

## Built-Ins

### No Shadowing

Built-in forms are all special, in that they cannot be shadowed: built-in values cannot be shadowed in any context, and syntactic forms `(<operator> <operand> ...)` cannot be shadowed in procedural context. For example, re-defining `car` will not change the behavior of `(car '(1 2))`, but the re-defined `car` will be visible in `(((lambda (x) x) car) '(1 2))`.

### `t`, `nil`

Like in Common Lisp, the expressions `t` and `nil` are self-evaluating and denote true and false respectively.

### `if`

The expression `(if <test> <consequent> <alternate>)` is evaluated by first evaluating `<test>` and then evaluating the `<consequent>` or the `<alternative>` depending on whether the `<test>` value is non-`nil` (true) or `nil`.

Unlike in Scheme and Common Lisp, the `<alternate>` expression cannot be omitted.

### `lambda`

The expression `(lambda <formals> <body>)` evaluates to a procedure.

The environment in effect when the `lambda` expression was evaluated is remembered as part of the procedure (a closure). When the procedure is later called with some actual arguments, the environment in which the `lambda` expression was evaluated will be extended by binding the variables in the formal argument list to the corresponding actual argument values, and the expression in the body of the `lambda` expression will be evaluated in the extended environment. The result of the expression in the body will be returned as the result of the procedure call.

The `<formals>` must be a (possibly empty) list of variable names, `(<variable1> ...)`, denoting a fixed number of arguments. The `<body>` term must be exactly one expression (unlike Scheme).

In a procedure call `(<operator> <operand> ...)`, assuming `<operator>` is not a built-in form, the `<operator>` should evaluate to a procedure (a closure), and the remaining arguments `<operand> ...` are evaluated from left to right.

Auto-currying: `lambda` expressions taking multiple parameters are automatically transformed into nested `lambda` expressions of one parameter each. Correspondingly, application of multiple arguments are automatically transformed into nested applications of one argument each. Auto-currying naturally supports partial applications. Hence a procedure does not need to be called with exactly the same number of arguments as the number of formals.


### `let`

In the expression `(let <bindings> <body>)`, `<bindings>` must have the form `((<variable1> <init1>) ...)` and body must be exactly one expression (unlike Scheme).

In a `let` expression, the bindings are performed sequentially from left to right, like Scheme's `let*` and unlike Scheme's `let`, which establishes bindings in paralell.

The region of a binding indicated by `(<variable> <init>)` is that part of the `let` expression to the right of the binding. Thus the second binding is done in an environment in which the first is visible, and so on.

### `letrec`

The `letrec` expression has the same form as the `let` expression: `(letrec <bindings> <body>)`.

In a `letrec` expression, the bindings are performed sequentially from left to right.

The region of a binding indicated by `(<variable> <init>)` is that part of the `let` expression to the right of the binding _but including itself_. Thus the second binding is done in an environment in which the first and second are visible, and so on.

Note: Lurk's `letrec` is unlike Scheme's `letrec` in that only self (not mutual) recursion is allowed. It is similar in evaluation order to Scheme's `letrec*`, but not in the regions.

### `quote`

The expression `(quote <datum>)` or `'<datum>` evaluates to `<datum>`.

### `atom`

The expression `(atom <e>)` evaluates to `t` if `<e>` evaluates to an atom (non-list) and to `nil` if `<e>` evaluates to a non-atom (list).

### `cons`, `strcons`, `car`, `cdr`

The expression `(cons <a> <d>)` produces a pair whose `car` is the result of evaluating `<a>` and whose `cdr` is the result of evaluating `<d>`. The expression `(car <e>)` and `(cdr <e>)` return the `car` and `cdr` of the pair resulting from the evaluation of `<e>`.

When `<a>` evaluates to a character and `<d>` evaluates to a string, `(strcons <a> <d>)` produces a string. When `<e>` is a string rather than a pair, the expression `(car <e>)` returns the first character (and `nil` when the argument is the empty string) and the expression `(cdr <e>)` returns the substring without the first character (and the empty string when the argument is the empty string).

Consing is implemented by hash-consing.

It is an error to call `strcons` with arguments of types other than character and string as described above.

It is an error to call `car` or `cdr` on an argument value that is not a pair or a string.

### `num`, `char`

The expression `(num <e>)` first evaluates `<e>`. In the case `<e>` evaluates to a character, `num` returns the `u32` ASCII value of the result. In the case of a Num, `num` returns the Num. In the case of a commitment, `num` returns the underlying Num (analogous to what happens when coercing a character to number). 

When `<n>` evaluates to a Num, the expression `(char <n>)` evaluates to the character which has the ASCII value of `<n>`. If `<n>` is not a valid ASCII value, an error is thrown. When `<c>` evaluates to a character, `(char <c>)` evaluates to `<c>`.

It is an error to call `num` and `char` on anything not a Num or character.

### Arithmetic operations `+`, `-`, `*`, `/`, `>`, `>=`, `<`, `<=`

Arithmetic operations are defined over a prime field `F_p`, where the order `p` is a parameter of the language. 

Let `+`, `-`, `*`, `/`, `>`, `>=`, `<`, `<=` be noted as `<op>`. The expression `(<op> <e1> <e2>)` evaluates by first evaluating `<e1>` and `<e2>` in order. The resulting values should be Nums. Then, the operation `op` is performed on these two Nums.

Comparsions interpret Nums as signed. The first half ranging from `0` to `(p - 1)/2` is considered positive. The second half ranging from `(p - 1)/2 + 1` to `p - 1` is considered negative. For every positive `n`, there is a corresponding negative `m`, such that `n + m = 0`. The result is that the interpretation of signed Nums implied by the definition of < (etc.) is arithmetically consistent.

### `=`, `eq`

The expression `(= <e1> <e2>)` evaluates by first evaluating the expressions `<e1>` and `<e2>`. The resulting values should be Nums. Then, they are compared for equality (over the prime field).

The expression  `(eq <e1> <e2>)` evaluates by first evaluating the expressions `<e1>` and `<e2>` and then comparing the resulting values. Deep equality is used.

### `emit`

The expression `(emit <e>)` evaluates the expression `<e>` and "emits" as well as returns the resulting value.
Emitting is an implementation-specific operation that makes the value visible to the outside world.

### `begin`

The expression `(begin <e> ...)` evaluates each expression `<e>` in order and returns the result of evaluating the last expression.

### `current-env`

The expression `(current-env)` evaluates to the current environment represented as an association list.

### `eval`

The expression `(eval <exp>)` or `(eval <exp> <env>)` first evaluates the expression `<exp>`, and then evaluates the resulting value treated as an expression in the environment obtained from the evaluation of `<env>`. If the argument `<env>` is omitted, the empty environment is used.

While `eval` is part of core Lurk, it is not part of the initial `lurk-rs` release.

## Numeral Parsing 

The reader has support for parsing negative Nums `-<n>` and fractional Nums `<n>/<m>`. 

A Num preceded by `-` is substracted from `0` at read time. 

A Num `<n>` preceded by `/` and another Num `<m>` is calculated at read-time by performing a field-element division. This means that for arithmetic and algebraic purposes, the resulting field elements appear to behave like the corresponding rationals. However, note carefully, that this similarity does not extend to relational comparisons. For example, `(< 1/2 1/3) => t`, since `1/2` is the most negative Num, although this violates expectations if you consider 1/2 to behave like a rational.  

## Values

The values of the language are `t`, `nil`, procedures such as those created by `lambda`, (field) Nums such as `18`, symbols such as the `foo` datum resulting from the evaluation of the quoted expression `'foo`, strings such as `"foo"`, characters such as `#\a`, and conses such as `(1 . 2)` or `(1 a "t")`.
